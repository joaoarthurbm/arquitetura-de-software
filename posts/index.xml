
   <rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
     <channel>
       <title>Posts on Arquitetura de Software</title>
       <link>https://joaoarthurbm.github.io/arquitetura-de-software/posts/</link>
       <description>Recent content in Posts on Arquitetura de Software</description>
       <generator>Hugo -- gohugo.io</generator>
       <copyright>Copyright &amp;copy; 2020 - João Arthur Brunet</copyright>
       <lastBuildDate>Wed, 23 Oct 2019 00:00:00 -0300</lastBuildDate>
       
           <atom:link href="https://joaoarthurbm.github.io/arquitetura-de-software/posts/index.xml" rel="self" type="application/rss+xml" />
       
       
       <item>
         <title>Deepmind: Arquitetura de Software e Aprendizagem de Máquina</title>
         <link>https://joaoarthurbm.github.io/arquitetura-de-software/posts/deepmind/</link>
         <pubDate>Wed, 23 Oct 2019 00:00:00 -0300</pubDate>
         
         <guid>https://joaoarthurbm.github.io/arquitetura-de-software/posts/deepmind/</guid>
         <description>&lt;hr&gt;
&lt;p&gt;Neste bate-papo, &lt;strong&gt;Marianne Monteiro&lt;/strong&gt; fala sobre as preocupações arquiteturais envolvidas no desenvolvimento de sistemas que utilizam aprendizagem de máquina. Algumas preocupações arquiteturais são trazidas para a discussão mais detalhada. Entre elas, destaco decisões sobre escalabilidade de maneira geral e sobre paralelismo de dados e de modelos. Por fim, foi muito interessante debater sobre propriedade intelectual de modelos, uma vez que há também a possibilidade de executá-los do lado do cliente.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;em&gt;Importante.&lt;/em&gt;&lt;/b&gt; O primeiro comentário do vídeo possui um índice, caso você queira pular direto para algum desses temas.&lt;/p&gt;
&lt;center&gt;
&lt;iframe width=&#34;560&#34; height=&#34;315&#34; src=&#34;https://www.youtube.com/embed/qluVuMYWQrM&#34; frameborder=&#34;0&#34; allow=&#34;accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture&#34; allowfullscreen&gt;&lt;/iframe&gt;
&lt;/center&gt;
&lt;hr&gt;
&lt;h2 id=&#34;minhas-notas-com-traços-de-opiniões&#34;&gt;Minhas notas (com traços de opiniões)&lt;/h2&gt;
&lt;p&gt;Marianne traz para discussão preocupações arquiteturais que emergem quando estamos tratando de aplicações que usam aprendizagem de máquina. Eu separei algumas delas para escrever mais detalhadamente.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;A separação treino/modelo.&lt;/b&gt; O treino não possui as mesmas restrições do modelos. Em primeiro lugar, sua execução pode demorar horas, dias e até semanas. Por não se tratar de código de produção, esse código pode executar em linguagens &amp;ldquo;mais lentas&amp;rdquo;, em máquinas diferentes das de produção etc. Por outro lado, o código do modelo tem requisitos bem estritos sobre desempenho. Nesse sentido, Marianne destacou, por exemplo, que o código de treino pode ser em Python e o de modelo em C++, que permite melhor controle sobre o desempenho e uso de memória. Marianne aponta vários exemplos de como separar treino e modelo. Desde os mais simples (cliente-servidor) até organizações mais complexas, discutindo detalhadamente os trade-offs envolvidos.&lt;/p&gt;
&lt;p&gt;Um ponto interessante aqui é a possibilidade de enviar o modelo para o cliente. Embora, como toda decisão arquitetual, haja vantagens em sua adoção, alguns pontos importantes foram levantados para discussão. Por exemplo, o modelo é, de certa forma, a chave do negócio de muitas empresas. Então é importante manter o sigilo e propriedade intelectual. Isso é muito dificultado se o modelo estiver sendo executado do lado do cliente. Aqui há uma clara decisão arquitetural a ser tomada tendo requisitos não-funcionais conflitantes, como simplicidade, desempenho, sigilo e propriedade intelectual.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Escalando modelos.&lt;/b&gt; Marianne discute detalhadamente abordagens sobre como escalar o treinamento de modelos. Naturalmente, tudo depende das restrições impostas pelos dados. Por exemplo, se os dados couberem em memória, é lá que são pré-processados. A execução do modelo pode ser, por exemplo, em CPU, GPUs ou em um conjunto desses componentes. Tanto escala vertical como horizontal são discutidas por Marianne em sua apresentação.&lt;/p&gt;
&lt;p&gt;Marianne debate muito bem sobre o conceito de paralelismo de dados e de modelos. As decisões arquiteturais giram em torno de paralelizar dados, modelos ou ambos. Lembrando sempre que isso traz complexidade ao sistema e, por isso, as decisões devem ser analisadas com cuidado antes.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Perguntas importantes.&lt;/b&gt; Uma lista de perguntas importantes apontadas por Marianne descreve bem as preocupações arquiteturais. Exemplos:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Onde estão os dados? Qual o formato?&lt;/li&gt;
&lt;li&gt;Modelo cabe em memória?&lt;/li&gt;
&lt;li&gt;Quantas GPUs preciso para treinar o modelo de forma eficiente?&lt;/li&gt;
&lt;li&gt;Quanto tempo posso levar para treinar um modelo?&lt;/li&gt;
&lt;li&gt;Como pré-processo meus dados?&lt;/li&gt;
&lt;li&gt;Quais métricas são importantes?&lt;/li&gt;
&lt;/ul&gt;
</description>
       </item>
       
       <item>
         <title>Fraunhofer: Arquitetura de Software para indústria 4.0</title>
         <link>https://joaoarthurbm.github.io/arquitetura-de-software/posts/fraunhofer/</link>
         <pubDate>Wed, 23 Oct 2019 00:00:00 -0300</pubDate>
         
         <guid>https://joaoarthurbm.github.io/arquitetura-de-software/posts/fraunhofer/</guid>
         <description>&lt;hr&gt;
&lt;p&gt;Neste bate-papo, &lt;strong&gt;Pablo Antonino&lt;/strong&gt;, gerente do departamento de engenharia de software embarcados do instituto Fraunhofer, fala sobre arquitetura de software para a indústria 4.0. O papo foca muito na experiência de Pablo em lidar com requisitos de sistemas que operam em chão de fábrica.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;em&gt;Importante.&lt;/em&gt;&lt;/b&gt; O primeiro comentário do vídeo possui um índice, caso você queira pular direto para algum desses temas.&lt;/p&gt;
&lt;center&gt;
&lt;iframe width=&#34;560&#34; height=&#34;315&#34; src=&#34;https://www.youtube.com/embed/Dkm-9ewb9Ak&#34; frameborder=&#34;0&#34; allow=&#34;accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture&#34; allowfullscreen&gt;&lt;/iframe&gt;
&lt;/center&gt;
&lt;hr&gt;
&lt;h2 id=&#34;minhas-notas-com-traços-de-opiniões&#34;&gt;Minhas notas (com traços de opiniões)&lt;/h2&gt;
&lt;p&gt;&lt;b&gt;Domínio diferente.&lt;/b&gt; Tipicamente, até aqui, discutimos bastante arquitetura de software para sistemas de informação, redes sociais, sistemas bancários etc. Pablo nos trouxe exemplos de sistemas de chão de fábrica e que, por isso, possuem requisitos consideravelmente diferentes dos que estamos acostumados a discutir.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Princípios fundamentais.&lt;/b&gt; Uma primeira impressão que tive do encontro foi o fato de que os princípios fundamentais estão sempre lá. Mesmo em um domínio diferente, com stakeholders diferentes, as decisões arquiteturais comumente giram em torno de princípios como separação entre implementação e interface, coesão em componentes, baixo acoplamento, interfaces bem definidas para comunicação por serviços etc.&lt;/p&gt;
&lt;p&gt;&amp;ndash;&lt;/p&gt;
&lt;p&gt;sobre o intituto
sobre 4.0
conceitos arquiteturais para 4.0 - 38:50
o processo de adptar estilos para novos contextos&lt;/p&gt;
&lt;p&gt;&amp;mdash;-//&amp;mdash;-&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;há muito o trabalho de adaptabilidade de soluções pré-existentes, né? os fundamentos estão lá.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;aplicação dos conceitos, né?  camadas/piramides -&amp;gt; P2P. SOA. separar interface de implementação. serviços. interfaces expostas e bem definidas.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;RAMI: ARQUIETTURA DE REFERÊNCIA QUE TEM EM SUA DEFINIÇÃO CONCEITOS ARQUITETURAIS&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;RAMI  é super novo, mas em camadas.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;decisões arquiteturais - relevantes para um contexto, mas não para outro. o conceito de visões arquiteturais.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;adaptabilidade&lt;/li&gt;
&lt;li&gt;evolução rápida&lt;/li&gt;
&lt;li&gt;tolerância a falhas&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;TRADEOFFs. + complexidade .. desempenho?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;documentação arquitetural - creio que há níveis de documentação porque vocês tratam de SISTEMAS CRÍTICOS&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;como parte do negócio! precisa ter para ter a certificação. Mesmo assim, não é uma infinidade de documentos.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;papel do arquiteto é bem definido? quão distante ele está da implementação das decisões que toma?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;como é o caminho até ser um arquiteto.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;sobre ser professor e trabalhar com isso na prática.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
       </item>
       
       <item>
         <title>OpenStack: Autenticação e Autorização</title>
         <link>https://joaoarthurbm.github.io/arquitetura-de-software/posts/openstack/</link>
         <pubDate>Wed, 23 Oct 2019 00:00:00 -0300</pubDate>
         
         <guid>https://joaoarthurbm.github.io/arquitetura-de-software/posts/openstack/</guid>
         <description>&lt;hr&gt;
&lt;p&gt;Neste bate-papo, &lt;strong&gt;Rodrigo Duarte&lt;/strong&gt; nos apresenta dois aspectos arquiteturais do OpenStack. Em primeiro lugar, a migração de monilito para microsserviços e, depois, a evolução do esquema de tokens para autenticação e autorização no OpenStack.&lt;/p&gt;
&lt;p&gt;É muito interessante a maneira como cada escolha tomada ao longo do tempo possui um tradeoff. Nós discutimos bastante a respeito desses tradeoffs, além de outros aspectos arquiteturais, como evolução de monolito para microsserviços, documentação arquitetural, avaliação das decisões e metodologia científica, além do papel do arquiteto.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;em&gt;Importante.&lt;/em&gt;&lt;/b&gt; O primeiro comentário do vídeo possui um índice, caso você queira pular direto para algum desses temas.&lt;/p&gt;
&lt;center&gt;
&lt;iframe width=&#34;560&#34; height=&#34;315&#34; src=&#34;https://www.youtube.com/embed/PuCSjWzWRuQ&#34; frameborder=&#34;0&#34; allow=&#34;accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture&#34; allowfullscreen&gt;&lt;/iframe&gt;
&lt;/center&gt;
&lt;hr&gt;
&lt;h2 id=&#34;minhas-notas-com-traços-de-opiniões&#34;&gt;Minhas notas (com traços de opiniões)&lt;/h2&gt;
&lt;blockquote&gt; Arquitetura de software é um exercício constante de se perguntar &#34;E se?&#34; &lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;- E se a carga duplicar?
- E se esse serviço sair do ar?
- E se implantar na nuvem for caro?
- E se houver free-riders?
- E se as consultas demandarem muito processamento/memória?
- E se eu usar cache? E se houver inconsistência?
- E se a minha estratégia para melhorar o desempenho piorar 
o desempenho?
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Decisões arquiteturais são transversais, firmes e de grande impacto.&lt;/p&gt;
&lt;p&gt;Toda decisão expõe um tradeoff.&lt;/p&gt;
&lt;p&gt;Migrar para microsserviços resolve muita coisa, mas também implica em uma nova gama de problemas e complexidade adicional.&lt;/p&gt;
&lt;p&gt;O modelo como as estratégias de tokens foram avaliadas foi &amp;ldquo;coloca para executar e monitora&amp;rdquo;.&lt;/p&gt;
&lt;p&gt;Rodrigo citou a importância de se avaliar com uma metodologia adequada. Em particular, é uma bandeira interna dele essa preocupação. Segundo ele, houve casos em que as conclusões não eram adequadas porque não se usou intervalo de confiação, por exemplo.&lt;/p&gt;
&lt;p&gt;Rodrigo citou que o &amp;ldquo;modelo de RFC&amp;rdquo; é usado para documentação arquitetural. Na prática, um documento colaborativo para discussão das decisões.&lt;/p&gt;
&lt;p&gt;O código tende a caminhar de maneira muito mais veloz do que a documentação.&lt;/p&gt;
&lt;p&gt;Chamei a atenção para o fato de que a descrição arquitetural deve se basear no conceito de visões. Isto é, para quem estou descrevendo? Aspectos diferentes e níveis de detalhes diferentes para diferentes stakeholders.&lt;/p&gt;
&lt;p&gt;Também chamei a atenção para manter a documentação arquitetural apenas com aspectos realmente importantes. Esconder detalhes desnecessários.&lt;/p&gt;
&lt;p&gt;Discutimos brevemente o conceito de walking architecture e truck-factor. Lembrei que é um problema que as decisões fiquem concentradas em apenas alguns membros. Rodrigo citou que isso acontece.&lt;/p&gt;
&lt;p&gt;Rodrigo lembrou que, gradativamente, foi percebendo que suas decisões não eram locais. Aliado ao fato de que em alguns momentos ele era &lt;em&gt;fullstack developer&lt;/em&gt;, esse cenário o fez &amp;ldquo;mais solidário&amp;rdquo;, uma vez que o impacto da mudança poderia afetar, por exemplo, a implantação e ele era quem também cuidava dessa etapa.&lt;/p&gt;
</description>
       </item>
       
       <item>
         <title>globo.com: Streaming via P2P</title>
         <link>https://joaoarthurbm.github.io/arquitetura-de-software/posts/globo/</link>
         <pubDate>Tue, 22 Oct 2019 00:00:00 -0300</pubDate>
         
         <guid>https://joaoarthurbm.github.io/arquitetura-de-software/posts/globo/</guid>
         <description>&lt;hr&gt;
&lt;p&gt;Neste encontro, Flávio Ribeiro fala sobre como aplicou o estilo arquitetural peer-to-peer (P2P) na globo.com para entregar streaming de melhor qualidade.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;em&gt;Importante.&lt;/em&gt;&lt;/b&gt; O primeiro comentário do vídeo possui um índice, caso você queira pular direto para algum desses temas.&lt;/p&gt;
&lt;center&gt;
&lt;iframe width=&#34;560&#34; height=&#34;315&#34; src=&#34;https://www.youtube.com/embed/tJ_ns20SIaU&#34; frameborder=&#34;0&#34; allow=&#34;accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture&#34; allowfullscreen&gt;&lt;/iframe&gt;&lt;/center&gt;
&lt;h3 id=&#34;motivação-para-adotar-p2p&#34;&gt;Motivação para adotar P2P&lt;/h3&gt;
&lt;p&gt;São vários os bons momentos que podem ser extraídos dessa conversa. Em particular, gostei bastante do fato de que a motivação de Flávio teve relação com a falta de recursos (banda) na região em que morava. Ou seja, a decisão arquitetural foi tomada tendo como norte o requisito não-funcional latência e foi provocada pelo ambiente em que vivia.&lt;/p&gt;
&lt;p&gt;O sistema foi desenvolvido em forma de plugin para facilitar implantação, testes e experimentação.&lt;/p&gt;
&lt;h3 id=&#34;migração-de-monolito-para-componentesplugin&#34;&gt;Migração de monolito para componentes/plugin&lt;/h3&gt;
&lt;p&gt;Também foi interessante o modo como ele remodelou o &lt;em&gt;player&lt;/em&gt; de vídeo da globo.com. A arquitetura inicial era monolito e foi migrada para o conceito de componentes/plugin (&lt;a class=&#34;external&#34; href=&#34;http://blog.flavioribeiro.com/clappr-an-extensible-media-player-for-the-web/&#34;&gt;clappr&lt;/a&gt;). Isso possibilitou a troca de ângulos nos jogos da Copa do Mundo de 2014 sem a necessidade de redesenhar todos os componentes na tela. Isso o player, suas funções e o local onde o vídeo é exibido são diferentes componentes.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;minhas-notas-com-traços-de-opiniões&#34;&gt;Minhas notas (com traços de opiniões)&lt;/h2&gt;
&lt;p&gt;&lt;b&gt;&lt;em&gt;Criatividade.&lt;/em&gt;&lt;/b&gt; O caso apresentado por Flávio me lembrou uma máxima: a ausência de recursos te faz criativo. Isso tem muita relação com arquitetura de software também. Fávio optou pelo estilo arquitetural P2P porque havia restrições de banda larga.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;em&gt;Melhoria na infraestrutura vs. Aumento no consumo de recursos dos software.&lt;/em&gt;&lt;/b&gt; Uma pergunta natural é: &amp;ldquo;a banda não melhorou significativamente ao longo do tempo?&amp;rdquo;. A resposta é: sim, mas o conteúdo passou a ser mais rico e exigir mais. Ou seja, a máxima &amp;ldquo;mais recursos computacionais não resolveram o problema&amp;rdquo;. O software precisou também resolver.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;em&gt;Arquitetura híbrida.&lt;/em&gt;&lt;/b&gt; Flávio optou por um modelo hierárquivo de P2P. Ou seja, há classes de nós dentro da rede. Nem todos estão no mesmo nível. Os pontos de presença, que possuem mais recursos, fazem parte da rede, mas estão em um nível acima dos &amp;ldquo;clientes finais&amp;rdquo;.&lt;/p&gt;
&lt;p&gt;P2P foi uma estratégia adotada para aproveitar banda de pares &amp;ldquo;mais privilegiados&amp;rdquo; estão &amp;ldquo;disperdiçando&amp;rdquo;.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;em&gt;Uma decisão traz um conjunto de preocupações.&lt;/em&gt;&lt;/b&gt; Decidir pelo estilo P2P trouxe preocupações adicionas:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Como avaliar pares na rede? Fávio criou um esquema de pontuação para eleger pares com boas conexões.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Como fazer com que os pares não se aproveitem da rede para distribuir outro conteúdo?&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;A implementação também foi através de plugin para ter agilidade nos testes e implantação.&lt;/p&gt;
&lt;p&gt;Flávio conduziu experimentação para avaliar as decisões arquiteturais.&lt;/p&gt;
&lt;p&gt;Flávio também lembrou que é muito comum o modelo de RFC para documentação arquitetural.&lt;/p&gt;
&lt;p&gt;Houve uma discussão interessante sobre quem toma as decisões arquiteturais. Varia, mas é comum que toda a equipe discuta e que os desenvolvedores &amp;ldquo;mais&amp;rdquo; senior conduzam as discussões.&lt;/p&gt;
</description>
       </item>
       
     </channel>
   </rss>
